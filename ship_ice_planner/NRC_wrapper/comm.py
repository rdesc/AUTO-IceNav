# Copyright (c) 2020, National Research Council Canada. All rights reserved.
"""
Contains common network communication types, functions, and helpers. That defined in here is typically used in
other higher level communication modules.
"""

import socket
from select import select
from struct import Struct

try:
    from ocre.net import receive_all
except ImportError:
    print('Could not import the NRC `ocre` package!')


# --- Basic TCP based connetion.

class ConnectionTimeoutError(ConnectionError):
    """
    Error raised when an operation on a socket or connection timed out. Only raised if the connection
    has been configured to timeout.
    """
    pass


class ConnectionAddressError(ConnectionError):
    """ Error raised for socket address related errors. """
    pass


class RemoteError(Exception):
    """
    A base class for errors generated by the other end, the remote end, of a connection.
    This usually means the remote end sent an error.
    """
    def __init__(self, message, code=0):
        self.code = code
        self.message = message
        if message:
            message += " Remote error code " + str(code) + "."
        else:
            message = "Remote error code " + str(code) + "."
        super().__init__(message)


class MessageConnection:
    """
    Base class for server and client connections.

    All messages (send/receive) have the same header. This useful for sharing code between client and server
    serializing and deserializing code.
    """

    # little-endian, message type (int32), size (int32)
    _header_fmt = "<ii"

    def __init__(self, address):
        """
        *address*:
            A tuple of the form (ip_address, port). Type: Tuple[str, int]
        """
        super().__init__()
        self._address = address
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._header = Struct(self._header_fmt)
        self._opened = False

    @classmethod
    def from_existing_socket(cls, socket_, address, opened=True):
        """
        Creates a connection from an existing socket, usually already opended. 

        Example usage: `MessageConnection.from_existing_socket(*server_socket.receive())`.

        *socket_*:
            A socket instance, as defined in :mod:`socket.socket`.

        *address*:
            A tuple of the form (ip_address, port). Type: Tuple[str, int]

        *opened*:
            If the given *socket_* is already opended. Default is True.
        """
        conn = cls(address)
        conn._socket = socket_
        conn._opened = opened
        return conn

    def connect(self):
        """ Connects the connection to the address given during object creation.

        Trying to open a closed socket will raise a :class:`ConnectionError`. If you need
        to establish another connection, create a new instance of this class. This is the same behavior
        as :obj:`socket.socket.connect`.

        Can raise a :class:`ConnectionTimeoutError`, :class:`ConnectionAddressError` or
        :class:`ConnectionError`.
        """
        if self._opened:
            raise ConnectionError("Connection already opened to " + str(self._address) + ".")

        # Under normal circumstances, we shouldn't have to wait too long for a connection.
        self._socket.settimeout(5)  # seconds

        try:
            self._socket.connect(self.address)
            self._opened = True
        except socket.timeout:
            raise ConnectionTimeoutError("Connecting timed out.")
        except (socket.gaierror, socket.herror) as ae:
            raise ConnectionAddressError("Address error. " + str(ae))
        except Exception as e:
            raise ConnectionError("Could not connect to {0}; {1}".format(self.address, e))

        # Normally enough seconds to receive a response. 
        self._socket.settimeout(10)

    def opened(self):
        """ Returns true if the connection is opened. """
        return self._opened

    @property
    def address(self):
        """ Returns the connection address as a tuple: (address, port)."""
        return self._address

    def close(self):
        """ Shuts down and closes the connection. Does not raise an exception. """
        if not self._opened:
            return

        try:
            # Will throw if not opened, but that's ok.
            self._socket.shutdown(socket.SHUT_RDWR)
        except Exception:
            # We don't care, where shutting down anyway. Moreover, this is expected if the
            # connection is really not open.
            pass
        finally:
            try:
                self._socket.close()
            except Exception:
                # What to do here?
                pass
            finally:
                self._opened = False

    def send_raw_message(self, message_type, body=None):
        """
        Sends a message.

        *message_type*
            The :obj:`int` message type.
        *body* 
            The optional message body already serialized.
        """

        # Never call sendall twice to send a message because you will get a huge performance hit
        # on the subsequent call to receive. For some messages, sending the message with one
        # call to sendall() is 30 times faster than using two calls (one for head one for body).
        try:
            body = body if body else b""
            self._socket.sendall(self._header.pack(message_type, len(body)) + body)
        except socket.timeout:
            raise ConnectionTimeoutError("Receive timed out.")
        except Exception as e:
            raise ConnectionError("Socket to {} failed to send message. {}".format(self._address, e))

    def receive_raw_message(self, expected=None):
        """
        Reads a message and unpacks the message type from the raw body (payload).  Returns a tuple of the form
        (message_type, body), where message_type is an in and body is the raw, unparsed payload.  The body may
        be None, indicating no body content.
        """
        try:
            msg_type, body_size = self._header.unpack(self._receive_all(self._header.size))
            body = self._receive_all(body_size)
        except socket.timeout:
            raise ConnectionTimeoutError("Receive timed out.")
        except Exception as e:
            raise ConnectionError("Error on connection to {} while receiving. {}".format(self._address, e))

        if expected is not None:
            if expected != msg_type:
                raise ConnectionError("Unexpected message type of {}, expected {}.".format(msg_type, expected))

        return msg_type, body
    
    def data_available(self):
        message_ready, _writable, _error = select([self._socket], [], [], 0)
        return bool(message_ready)

    def set_timeout(self, timeout):
        """ Set the socket timeout in seconds.  """

        self._socket.settimeout(timeout)    

    def _receive_all(self, size):
        return receive_all(self._socket, size)
